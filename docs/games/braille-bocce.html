<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Royal Braille Bocce</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700;900&family=Roboto+Condensed:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1e3c29;
            background-image: 
                url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.12'/%3E%3C/svg%3E"),
                radial-gradient(circle at 50% 40%, #2a5038 0%, #1e3c29 60%, #11251a 100%);
            color: #ecf0f1;
            font-family: 'Roboto Condensed', sans-serif;
            overflow: hidden;
            user-select: none;
            cursor: none; 
        }

        /* --- CUSTOM CURSOR --- */
        #custom-cursor {
            position: fixed;
            top: 0; left: 0;
            width: 20px; height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            transition: width 0.1s, height 0.1s, border-color 0.2s;
        }
        /* Cursor states */
        body.cursor-grab #custom-cursor {
            width: 40px; height: 40px;
            background: rgba(255,255,255,0.1);
            border-style: dashed;
        }

        /* --- UI CONTAINERS (CARDS) --- */
        #game-ui {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
        }

        .player-card {
            position: absolute;
            top: 30px;
            width: 240px;
            height: 320px;
            background: #fdfaf5; 
            color: #2c3e50;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.6); 
            padding: 20px;
            box-sizing: border-box;
            text-align: center;
            border: 1px solid #dcdde1;
            transform: rotate(0deg);
            transition: transform 0.3s, box-shadow 0.3s, opacity 0.3s;
        }

        #card-red { left: 40px; transform: rotate(-2deg); }
        #card-blue { right: 40px; transform: rotate(2deg); }

        .active-turn {
            transform: scale(1.05) rotate(0deg) !important;
            box-shadow: 0 20px 40px rgba(0,0,0,0.8) !important;
            border: 2px solid #f1c40f;
            z-index: 10;
        }
        
        .dimmed { opacity: 0.5; }

        .card-header {
            font-family: 'Playfair Display', serif;
            font-weight: 900;
            font-size: 24px;
            border-bottom: 2px solid #2c3e50;
            padding-bottom: 10px;
            margin-bottom: 15px;
            text-transform: uppercase;
        }

        .target-big {
            font-family: 'Playfair Display', serif;
            font-size: 100px;
            line-height: 0.8;
            font-weight: 900;
            margin: 10px 0;
            color: #333;
        }

        .braille-box {
            background: #ecf0f1;
            border-radius: 6px;
            padding: 15px;
            margin: 10px auto;
            width: 80px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.1);
        }

        .b-dot {
            width: 16px; height: 16px;
            border-radius: 50%;
            background: #bdc3c7; 
        }
        .b-dot.active {
            background: #2c3e50; 
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        #dealer-chip {
            position: absolute;
            width: 50px; height: 50px;
            background: radial-gradient(circle at 30% 30%, #f1c40f, #f39c12);
            border: 2px dashed #d35400;
            border-radius: 50%;
            box-shadow: 0 5px 10px rgba(0,0,0,0.5);
            top: -25px; left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 10px;
            color: #6e2c00;
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* --- CONTROLS --- */
        #controls-overlay {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 20;
        }

        .felt-text {
            font-family: 'Playfair Display', serif;
            color: rgba(255,255,255,0.6);
            font-size: 20px;
            letter-spacing: 2px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.9);
            text-transform: uppercase;
            background: rgba(0,0,0,0.4);
            display: inline-block;
            padding: 5px 20px;
            border-radius: 20px;
            margin-bottom: 10px;
        }

        .action-btn {
            pointer-events: auto;
            background: #e6cc80;
            color: #2c3e50;
            border: 1px solid #b39536;
            padding: 12px 35px;
            font-family: 'Playfair Display', serif;
            font-weight: bold;
            font-size: 18px;
            border-radius: 4px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            cursor: none; 
            margin-top: 5px;
            transition: transform 0.1s, filter 0.1s;
        }
        .action-btn:hover { filter: brightness(1.1); }
        .action-btn:active { transform: translateY(2px); }

        canvas {
            display: block;
            position: absolute;
            top: 0; left: 0;
            z-index: 0;
        }
    </style>
</head>
<body>

    <div id="custom-cursor"></div>

    <div id="game-ui">
        <!-- RED CARD -->
        <div id="card-red" class="player-card active-turn">
            <div id="chip-red-anchor" style="position:absolute; top:0; left:0; width:100%; height:0;">
                <div id="dealer-chip">TURN</div>
            </div>
            <div class="card-header" style="color: #c0392b;">Red Player</div>
            <div style="font-size: 12px; color: #7f8c8d;">TARGET LETTER</div>
            <div class="target-big" id="red-target">A</div>
            <div class="braille-box" id="red-braille"></div>
            <div style="margin-top:15px; font-size:12px; color:#95a5a6;">SCORE: <span id="red-score">0/1</span></div>
        </div>

        <!-- BLUE CARD -->
        <div id="card-blue" class="player-card">
            <div id="chip-blue-anchor" style="position:absolute; top:0; left:0; width:100%; height:0;"></div>
            <div class="card-header" style="color: #2980b9;">Blue Player</div>
            <div style="font-size: 12px; color: #7f8c8d;">TARGET LETTER</div>
            <div class="target-big" id="blue-target">B</div>
            <div class="braille-box" id="blue-braille"></div>
            <div style="margin-top:15px; font-size:12px; color:#95a5a6;">SCORE: <span id="blue-score">0/2</span></div>
        </div>

        <!-- Controls Centered -->
        <div id="controls-overlay">
            <div id="phase-text" class="felt-text">Drag to Shoot</div><br>
            <button id="phase-btn" class="action-btn" style="display:none;" onclick="advancePhase()">Next Phase</button>
            <br>
            <button id="new-match-btn" class="action-btn" style="font-size:12px; padding: 5px 15px; opacity:0.7; margin-top:15px;" onclick="startNewMatch()">Reset Match</button>
        </div>
    </div>

<script>
    // --- CURSOR ---
    const cursor = document.getElementById('custom-cursor');
    document.addEventListener('mousemove', e => {
        cursor.style.left = e.clientX + 'px';
        cursor.style.top = e.clientY + 'px';
    });
    document.addEventListener('mousedown', () => cursor.style.transform = "translate(-50%, -50%) scale(0.8)");
    document.addEventListener('mouseup', () => cursor.style.transform = "translate(-50%, -50%) scale(1)");

    // --- DATA ---
    const brailleMap = {
        'A': [1], 'B': [1,2], 'C': [1,4], 'D': [1,4,5], 'E': [1,5],
        'F': [1,2,4], 'G': [1,2,4,5], 'H': [1,2,5], 'I': [2,4], 'J': [2,4,5],
        'K': [1,3], 'L': [1,2,3], 'M': [1,3,4], 'N': [1,3,4,5], 'O': [1,3,5],
        'P': [1,2,3,4], 'Q': [1,2,3,4,5], 'R': [1,2,3,5], 'S': [2,3,4], 'T': [2,3,4,5],
        'U': [1,3,6], 'V': [1,2,3,6], 'W': [2,4,5,6], 'X': [1,3,4,6], 'Y': [1,3,4,5,6], 'Z': [1,3,5,6]
    };
    const lettersByDotCount = {};
    Object.keys(brailleMap).forEach(char => {
        const c = brailleMap[char].length;
        if(!lettersByDotCount[c]) lettersByDotCount[c] = [];
        lettersByDotCount[c].push(char);
    });

    // --- MATTER JS ---
    const Engine = Matter.Engine, Render = Matter.Render, Runner = Matter.Runner,
          Bodies = Matter.Bodies, Composite = Matter.Composite, Events = Matter.Events,
          Vector = Matter.Vector, Body = Matter.Body;

    const engine = Engine.create();
    engine.world.gravity.y = 0;

    const width = window.innerWidth;
    const height = window.innerHeight;
    const courtWidth = Math.min(900, width);
    
    // Config
    let foulLineY = height - 350; // Initial Position (Higher up)
    const holeRadius = 24;
    const ballRadius = 18;

    const render = Render.create({
        element: document.body,
        engine: engine,
        options: { width, height, wireframes: false, background: 'transparent' }
    });

    // --- STATE ---
    let gameState = 'SHOOTING'; // 'SHOOTING', 'RETRIEVAL_RED', 'RETRIEVAL_BLUE'
    let currentPlayer = 'red';
    let redAmmo = 4;
    let blueAmmo = 4;
    let redLetter = 'A';
    let blueLetter = 'B';
    
    let balls = [];
    let dragStart = null;   // For shooting
    let dragBall = null;    // For retrieval
    let dragLine = false;   // For foul line

    // --- COURT SETUP ---
    const holes = [];
    const startX = (width / 2) - 60;
    const startY = 120;
    const holePositions = [
        {x: startX, y: startY, id: 1}, {x: startX, y: startY + 100, id: 2}, {x: startX, y: startY + 200, id: 3},
        {x: startX + 120, y: startY, id: 4}, {x: startX + 120, y: startY + 100, id: 5}, {x: startX + 120, y: startY + 200, id: 6}
    ];

    // Walls
    const wallOpts = { isStatic: true, render: { visible: false }, restitution: 0.8 };
    Composite.add(engine.world, [
        Bodies.rectangle(width/2, -50, width, 100, wallOpts),
        Bodies.rectangle(width/2, height + 50, width, 100, wallOpts),
        Bodies.rectangle((width - courtWidth)/2 - 25, height/2, 50, height, wallOpts),
        Bodies.rectangle(width - (width - courtWidth)/2 + 25, height/2, 50, height, wallOpts)
    ]);

    // --- RENDERING LOOP ---
    Events.on(render, 'afterRender', function() {
        const ctx = render.context;

        // 1. Draw Foul Line & Zones
        ctx.save();
        
        // Hit area visual
        if (dragLine) {
             ctx.fillStyle = 'rgba(255,255,255,0.1)';
             ctx.fillRect((width - courtWidth)/2, foulLineY - 10, courtWidth, 20);
        }

        ctx.beginPath();
        ctx.moveTo((width - courtWidth)/2, foulLineY);
        ctx.lineTo(width - (width - courtWidth)/2, foulLineY);
        ctx.strokeStyle = dragLine ? 'rgba(255,255,255,0.8)' : 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 4;
        ctx.setLineDash([10, 10]);
        ctx.stroke();
        ctx.setLineDash([]);

        // Zone Labels
        ctx.font = "20px 'Playfair Display'";
        ctx.fillStyle = "rgba(231, 76, 60, 0.3)";
        ctx.fillText("RED ZONE", width/2 - 200, foulLineY + 100);
        ctx.fillStyle = "rgba(52, 152, 219, 0.3)";
        ctx.fillText("BLUE ZONE", width/2 + 120, foulLineY + 100);
        
        ctx.fillStyle = "rgba(255,255,255,0.3)";
        ctx.font = "12px Roboto Condensed";
        ctx.fillText("DRAG LINE TO ADJUST", width/2, foulLineY - 10);
        ctx.restore();

        // 2. Draw Holes
        holePositions.forEach(pos => {
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, holeRadius, 0, 2 * Math.PI);
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fill();
            // Highlight if target
            const isRed = brailleMap[redLetter].includes(pos.id);
            const isBlue = brailleMap[blueLetter].includes(pos.id);
            
            ctx.font = "14px Roboto Condensed";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "rgba(255,255,255,0.1)";
            ctx.fillText(pos.id, pos.x, pos.y + holeRadius + 15);
        });

        // 3. Draw Balls
        balls.forEach(ball => {
            // Visual Lift if dragged
            const isDragged = (ball === dragBall);
            
            // In sequential retrieval, dim balls that aren't ours
            let isDimmed = false;
            if (gameState === 'RETRIEVAL_RED' && ball.label === 'blue') isDimmed = true;
            if (gameState === 'RETRIEVAL_BLUE' && ball.label === 'red') isDimmed = true;

            drawBall3D(ctx, ball, isDragged, isDimmed);
        });

        // 4. Draw Aim Line
        if (gameState === 'SHOOTING' && dragStart) {
            const currentPos = dragStart.current || dragStart.start; 
            ctx.beginPath();
            ctx.moveTo(dragStart.start.x, dragStart.start.y);
            ctx.lineTo(currentPos.x, currentPos.y);
            ctx.strokeStyle = currentPlayer === 'red' ? '#e74c3c' : '#3498db';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // 5. Draw Ammo Trays
        drawAmmoTray(ctx, 'red', redAmmo, width/2 - 250, height - 80);
        drawAmmoTray(ctx, 'blue', blueAmmo, width/2 + 250, height - 80);
    });

    function drawBall3D(ctx, ball, lifted, dimmed) {
        const x = ball.position.x;
        const y = ball.position.y;
        const r = ball.circleRadius;
        let color = ball.label === 'red' ? {base: '#c0392b', light: '#e74c3c'} : {base: '#2980b9', light: '#3498db'};

        ctx.save();
        if (dimmed) ctx.globalAlpha = 0.4;

        // Shadow
        const shadowOff = lifted ? 15 : 3;
        const shadowBlur = lifted ? 10 : 2;
        const shadowAlpha = lifted ? 0.2 : 0.5;

        ctx.beginPath();
        ctx.arc(x + shadowOff, y + shadowOff, r, 0, 2 * Math.PI);
        ctx.fillStyle = `rgba(0,0,0,${shadowAlpha})`;
        ctx.filter = `blur(${shadowBlur}px)`;
        ctx.fill();
        ctx.filter = 'none';

        // Ball Body
        const grad = ctx.createRadialGradient(x - r/3, y - r/3, r/10, x, y, r);
        grad.addColorStop(0, color.light);
        grad.addColorStop(1, color.base);
        
        ctx.beginPath();
        ctx.arc(x, y, r, 0, 2 * Math.PI);
        ctx.fillStyle = grad;
        ctx.fill();
        
        ctx.restore();
    }

    function drawAmmoTray(ctx, player, count, cx, cy) {
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(cx - 70, cy - 30, 140, 60);
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.strokeRect(cx - 70, cy - 30, 140, 60);
        
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.font = '10px Roboto Condensed';
        ctx.textAlign = 'center';
        ctx.fillText("AMMO", cx, cy + 40);

        for(let i=0; i<count; i++) {
            const spacing = 30;
            const bx = cx - ((count-1)*spacing)/2 + i*spacing;
            const color = player === 'red' ? '#c0392b' : '#2980b9';
            ctx.beginPath();
            ctx.arc(bx, cy, 10, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.beginPath();
            ctx.arc(bx - 3, cy - 3, 4, 0, 2 * Math.PI);
            ctx.fill();
        }
    }

    // --- PHYSICS EVENTS ---
    Events.on(engine, 'beforeUpdate', function() {
        balls.forEach(ball => {
            if (ball === dragBall) return; 
            let inHole = false;
            for (let h of holePositions) {
                const dist = Vector.magnitude(Vector.sub(ball.position, {x: h.x, y: h.y}));
                if (dist < holeRadius) {
                    if (ball.speed < 5) {
                        const force = Vector.sub({x: h.x, y: h.y}, ball.position);
                        Body.applyForce(ball, ball.position, Vector.mult(force, 0.0006));
                        ball.frictionAir = 0.1;
                    }
                    inHole = true;
                }
            }
            if (!inHole) ball.frictionAir = 0.02;
        });
    });

    // --- INPUT HANDLING ---
    const canvas = document.querySelector('canvas');

    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        // 1. Foul Line Drag Check (Available anytime except maybe during a shot drag)
        if (Math.abs(my - foulLineY) < 15) {
            dragLine = true;
            return;
        }

        // 2. Game Logic
        if (gameState === 'SHOOTING') {
            if (currentPlayer === 'red' && redAmmo <= 0) return;
            if (currentPlayer === 'blue' && blueAmmo <= 0) return;
            if (my < foulLineY) return; // Must be below line
            if (currentPlayer === 'red' && mx > width/2) return;
            if (currentPlayer === 'blue' && mx < width/2) return;

            dragStart = { start: {x: mx, y: my}, current: {x: mx, y: my} };
        } 
        else if (gameState.startsWith('RETRIEVAL')) {
            // Check for balls
            const found = balls.find(b => Vector.magnitude(Vector.sub(b.position, {x: mx, y: my})) < ballRadius + 10);
            
            if (found) {
                // Enforce Turn
                if (gameState === 'RETRIEVAL_RED' && found.label !== 'red') return;
                if (gameState === 'RETRIEVAL_BLUE' && found.label !== 'blue') return;

                dragBall = found;
                dragBall.collisionFilter.category = 0x0000; // No collisions
                Body.setVelocity(dragBall, {x:0, y:0});
            }
        }
    });

    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        // Line Dragging
        if (dragLine) {
            foulLineY = Math.max(startY + 350, Math.min(my, height - 100));
            document.body.classList.add('cursor-grab');
            return;
        } else {
             // Hover effect for line
             if (Math.abs(my - foulLineY) < 15) document.body.classList.add('cursor-grab');
             else document.body.classList.remove('cursor-grab');
        }

        // Cursor styling for shooting zones
        if (gameState === 'SHOOTING') {
            if (my > foulLineY) {
                if ((currentPlayer === 'red' && mx < width/2) || (currentPlayer === 'blue' && mx > width/2)) {
                    cursor.style.borderColor = currentPlayer === 'red' ? '#e74c3c' : '#3498db';
                } else {
                    cursor.style.borderColor = '#fff';
                }
            } else {
                cursor.style.borderColor = 'rgba(255,255,255,0.2)';
            }
        }

        if (dragStart) dragStart.current = {x: mx, y: my};
        
        if (dragBall) {
            Body.setPosition(dragBall, {x: mx, y: my});
            Body.setVelocity(dragBall, {x: 0, y: 0});
        }
    });

    canvas.addEventListener('mouseup', (e) => {
        const rect = canvas.getBoundingClientRect();
        dragLine = false;

        if (gameState === 'SHOOTING' && dragStart) {
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            const rawVector = Vector.sub(dragStart.start, {x: mx, y: my});
            const len = Vector.magnitude(rawVector);

            if (len > 10) {
                // Power Scale
                const power = Math.min(len, 300) * 0.0006; 
                const force = Vector.mult(Vector.normalise(rawVector), power);
                
                spawnBall(dragStart.start.x, dragStart.start.y, force);

                if (currentPlayer === 'red') redAmmo--; else blueAmmo--;
                
                if (redAmmo === 0 && blueAmmo === 0) {
                    setTimeout(() => startRetrievalPhase('red'), 2500);
                } else {
                    const other = currentPlayer === 'red' ? 'blue' : 'red';
                    const otherAmmo = other === 'red' ? redAmmo : blueAmmo;
                    if (otherAmmo > 0) currentPlayer = other;
                    updateUI();
                }
            }
            dragStart = null;
        }
        else if (gameState.startsWith('RETRIEVAL') && dragBall) {
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            const isRedZone = mx < width/2 && my > height - 150;
            const isBlueZone = mx > width/2 && my > height - 150;
            const isCorrectZone = (dragBall.label === 'red' && isRedZone) || (dragBall.label === 'blue' && isBlueZone);

            if (isCorrectZone) {
                Composite.remove(engine.world, dragBall);
                balls = balls.filter(b => b !== dragBall);
                if(dragBall.label === 'red') redAmmo++; else blueAmmo++;
            } else {
                dragBall.collisionFilter.category = 0x0001;
            }
            dragBall = null;
            updateUI();
        }
    });

    function spawnBall(x, y, force) {
        const ball = Bodies.circle(x, y, ballRadius, {
            restitution: 0.6, friction: 0.001, frictionAir: 0.02, density: 0.002, label: currentPlayer
        });
        Body.applyForce(ball, ball.position, force);
        Composite.add(engine.world, ball);
        balls.push(ball);
    }

    // --- GAME FLOW ---

    function startNewMatch() {
        Composite.remove(engine.world, balls);
        balls = [];
        
        const counts = [2, 3, 4, 5];
        const count = counts[Math.floor(Math.random() * counts.length)];
        const pool = lettersByDotCount[count];
        let i1 = Math.floor(Math.random()*pool.length);
        let i2 = Math.floor(Math.random()*pool.length);
        while(pool.length > 1 && i1 === i2) i2 = Math.floor(Math.random()*pool.length);

        redLetter = pool[i1];
        blueLetter = pool[i2];

        renderBraille('red-braille', brailleMap[redLetter]);
        renderBraille('blue-braille', brailleMap[blueLetter]);
        document.getElementById('red-target').innerText = redLetter;
        document.getElementById('blue-target').innerText = blueLetter;
        
        redAmmo = 4; blueAmmo = 4;
        gameState = 'SHOOTING';
        currentPlayer = 'red';
        
        document.getElementById('phase-btn').style.display = 'none';
        updateUI();
    }

    function startRetrievalPhase(step) {
        // Step: 'red' or 'blue'
        if (step === 'red') {
            gameState = 'RETRIEVAL_RED';
            document.getElementById('phase-text').innerText = "RED: Drag your balls to your pouch";
            document.getElementById('phase-btn').innerText = "Finish Red Retrieval";
        } else {
            gameState = 'RETRIEVAL_BLUE';
            document.getElementById('phase-text').innerText = "BLUE: Drag your balls to your pouch";
            document.getElementById('phase-btn').innerText = "Finish Blue Retrieval";
        }

        document.getElementById('phase-btn').style.display = 'inline-block';
        document.getElementById('dealer-chip').style.opacity = '0';
        
        // Check win before retrieval starts (points on board)
        if(step === 'red') checkWin();
        updateUI();
    }

    // Accessible to HTML button
    window.advancePhase = function() {
        if (gameState === 'RETRIEVAL_RED') {
            startRetrievalPhase('blue');
        } else if (gameState === 'RETRIEVAL_BLUE') {
            // End Round
            if (redAmmo === 0 && blueAmmo === 0) {
                alert("Someone must retrieve ammo to continue!");
                return;
            }
            gameState = 'SHOOTING';
            currentPlayer = 'red';
            document.getElementById('phase-btn').style.display = 'none';
            document.getElementById('dealer-chip').style.opacity = '1';
            updateUI();
        }
    };

    function checkWin() {
        const rScore = getScore('red', redLetter);
        const bScore = getScore('blue', blueLetter);
        
        if (rScore === brailleMap[redLetter].length) {
            alert("Red Wins the Letter!");
            startNewMatch();
        } else if (bScore === brailleMap[blueLetter].length) {
            alert("Blue Wins the Letter!");
            startNewMatch();
        }
    }

    function getScore(player, letter) {
        const dots = brailleMap[letter];
        let score = 0;
        const occupation = {};
        
        holePositions.forEach(h => {
            let occ = null;
            balls.forEach(b => {
                if (Vector.magnitude(Vector.sub(b.position, h)) < holeRadius && b.speed < 0.5) occ = b.label;
            });
            occupation[h.id] = occ;
        });

        dots.forEach(id => { if(occupation[id] === player) score++; });
        return score;
    }

    function updateUI() {
        const redCard = document.getElementById('card-red');
        const blueCard = document.getElementById('card-blue');
        const phaseText = document.getElementById('phase-text');
        const chip = document.getElementById('dealer-chip');

        if (gameState === 'SHOOTING') {
            phaseText.innerText = currentPlayer === 'red' ? "Red's Throw" : "Blue's Throw";
            if (currentPlayer === 'red') {
                document.getElementById('chip-red-anchor').appendChild(chip);
                redCard.classList.add('active-turn'); redCard.classList.remove('dimmed');
                blueCard.classList.remove('active-turn'); blueCard.classList.add('dimmed');
            } else {
                document.getElementById('chip-blue-anchor').appendChild(chip);
                blueCard.classList.add('active-turn'); blueCard.classList.remove('dimmed');
                redCard.classList.remove('active-turn'); redCard.classList.add('dimmed');
            }
        } else {
            // Retrieval Highlighting
            if (gameState === 'RETRIEVAL_RED') {
                redCard.classList.add('active-turn'); redCard.classList.remove('dimmed');
                blueCard.classList.remove('active-turn'); blueCard.classList.add('dimmed');
            } else {
                blueCard.classList.add('active-turn'); blueCard.classList.remove('dimmed');
                redCard.classList.remove('active-turn'); redCard.classList.add('dimmed');
            }
        }
        
        const rScore = getScore('red', redLetter);
        const bScore = getScore('blue', blueLetter);
        document.getElementById('red-score').innerText = `${rScore}/${brailleMap[redLetter].length}`;
        document.getElementById('blue-score').innerText = `${bScore}/${brailleMap[blueLetter].length}`;
    }

    function renderBraille(elemId, dots) {
        const el = document.getElementById(elemId);
        el.innerHTML = '';
        for(let i=1; i<=6; i++) {
            const dot = document.createElement('div');
            dot.className = 'b-dot' + (dots.includes(i) ? ' active' : '');
            el.appendChild(dot);
        }
    }

    startNewMatch();
    Render.run(render);
    Runner.run(Runner.create(), engine);

</script>
</body>
</html>