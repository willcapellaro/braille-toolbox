{"version":3,"file":"advanced-blend-modes.min.js","sources":["../../src/advanced-blend-modes/ColorBlend.ts","../../src/advanced-blend-modes/ColorBurnBlend.ts","../../src/advanced-blend-modes/ColorDodgeBlend.ts","../../src/advanced-blend-modes/DarkenBlend.ts","../../src/advanced-blend-modes/DifferenceBlend.ts","../../src/advanced-blend-modes/DivideBlend.ts","../../src/advanced-blend-modes/ExclusionBlend.ts","../../src/advanced-blend-modes/HardLightBlend.ts","../../src/advanced-blend-modes/HardMixBlend.ts","../../src/advanced-blend-modes/LightenBlend.ts","../../src/advanced-blend-modes/LinearBurnBlend.ts","../../src/advanced-blend-modes/LinearDodgeBlend.ts","../../src/advanced-blend-modes/LinearLightBlend.ts","../../src/advanced-blend-modes/LuminosityBlend.ts","../../src/advanced-blend-modes/NegationBlend.ts","../../src/advanced-blend-modes/OverlayBlend.ts","../../src/advanced-blend-modes/PinLightBlend.ts","../../src/advanced-blend-modes/SaturationBlend.ts","../../src/advanced-blend-modes/SoftLightBlend.ts","../../src/advanced-blend-modes/SubtractBlend.ts","../../src/advanced-blend-modes/VividLightBlend.ts","../../src/advanced-blend-modes/init.ts"],"sourcesContent":["import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\nimport { hslgl } from '../filters/blend-modes/hls/GLhls';\nimport { hslgpu } from '../filters/blend-modes/hls/GPUhls';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * The final color has the hue and saturation of the top color, while using the luminosity of the bottom color.\n * The effect preserves gray levels and can be used to colorize the foreground.\n *\n * Available as `container.blendMode = 'color'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'color'\n * @category filters\n * @noInheritDoc\n */\nexport class ColorBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'color',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                ${hslgl}\n\n                vec3 blendColor(vec3 base, vec3 blend,  float opacity)\n                {\n                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendColor(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                ${hslgpu}\n\n                fn blendColorOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                out = vec4<f32>(blendColorOpacity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n            }\n        });\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * The final color is the result of inverting the bottom color, dividing the value by the top color,\n * and inverting that value. A white foreground leads to no change.\n * A foreground with the inverse color of the backdrop leads to a black final image.\n * This blend mode is similar to multiply, but the foreground need only be as dark as the inverse\n * of the backdrop to make the final image black.\n *\n * Available as `container.blendMode = 'color-burn'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'color-burn'\n * @category filters\n * @noInheritDoc\n */\nexport class ColorBurnBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'color-burn',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float colorBurn(float base, float blend)\n                {\n                    return max((1.0 - ((1.0 - base) / blend)), 0.0);\n                }\n\n                vec3 blendColorBurn(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        colorBurn(base.r, blend.r),\n                        colorBurn(base.g, blend.g),\n                        colorBurn(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                finalColor = vec4(blendColorBurn(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n            `\n            },\n            gpu: {\n                functions: `\n                fn colorBurn(base:f32, blend:f32) -> f32\n                {\n                    return max((1.0-((1.0-base)/blend)),0.0);\n                }\n\n                fn blendColorBurn(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        colorBurn(base.r, blend.r),\n                        colorBurn(base.g, blend.g),\n                        colorBurn(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                out = vec4<f32>(blendColorBurn(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n            }\n        });\n    }\n}\n","/* eslint-disable max-len */\n\nimport { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * The final color is the result of dividing the bottom color by the inverse of the top color.\n * A black foreground leads to no change.\n * A foreground with the inverse color of the backdrop leads to a fully lit color.\n * This blend mode is similar to screen, but the foreground need only be as light as the inverse of the backdrop to create a fully lit color.\n *\n * Available as `container.blendMode = 'color-dodge'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'color-dodge'\n * @category filters\n * @noInheritDoc\n */\nexport class ColorDodgeBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'color-dodge',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float colorDodge(float base, float blend)\n                {\n                    return base / (1.0 - blend);\n                }\n\n                vec3 blendColorDodge(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        colorDodge(base.r, blend.r),\n                        colorDodge(base.g, blend.g),\n                        colorDodge(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendColorDodge(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                fn colorDodge(base: f32, blend: f32) -> f32\n                {\n                    return base / (1.0 - blend);\n                }\n\n                fn blendColorDodge(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        colorDodge(base.r, blend.r),\n                        colorDodge(base.g, blend.g),\n                        colorDodge(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                    out = vec4<f32>(blendColorDodge(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `,\n            }\n        });\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * The final color is composed of the darkest values of each color channel.\n *\n * Available as `container.blendMode = 'darken'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'darken'\n * @category filters\n * @noInheritDoc\n */\nexport class DarkenBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'darken',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                vec3 blendDarken(vec3 base, vec3 blend, float opacity)\n                {\n                    return (min(base, blend) * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendDarken(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                fn blendDarken(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    return (min(blend,base) * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                out = vec4<f32>(blendDarken(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n            }\n        });\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * The final color is the result of subtracting the darker of the two colors from the lighter one.\n * black layer has no effect, while a white layer inverts the other layer's color.\n *\n * Available as `container.blendMode = 'difference'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'difference'\n * @category filters\n * @noInheritDoc\n */\nexport class DifferenceBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'difference',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                vec3 blendDifference(vec3 base, vec3 blend,  float opacity)\n                {\n                    return (abs(blend - base) * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                finalColor = vec4(blendDifference(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n            `\n            },\n            gpu: {\n                functions: `\n                fn blendDifference(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    return (abs(blend - base) * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                out = vec4<f32>(blendDifference(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n            }\n        });\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * The Divide blend mode divides the RGB channel values of the bottom layer by those of the top layer.\n * The darker the top layer, the brighter the bottom layer will appear.\n * Blending any color with black yields white, and blending with white has no effect\n *\n * Available as `container.blendMode = 'divide'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'divide'\n * @category filters\n * @noInheritDoc\n */\nexport class DivideBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'divide',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float divide(float base, float blend)\n                {\n                    return (blend > 0.0) ? clamp(base / blend, 0.0, 1.0) : 1.0;\n                }\n\n                vec3 blendDivide(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        divide(base.r, blend.r),\n                        divide(base.g, blend.g),\n                        divide(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendDivide(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                fn divide(base: f32, blend: f32) -> f32\n                {\n                    return select(1.0, clamp(base / blend, 0.0, 1.0), blend > 0.0);\n                }\n\n                fn blendDivide(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        divide(base.r, blend.r),\n                        divide(base.g, blend.g),\n                        divide(base.b, blend.b)\n                    );\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                out = vec4<f32>(blendDivide(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n            }\n        });\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * The final color is similar to difference, but with less contrast.\n * As with difference, a black layer has no effect, while a white layer inverts the other layer's color.\n *\n * Available as `container.blendMode = 'exclusion'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'exclusion'\n * @category filters\n * @noInheritDoc\n */\nexport class ExclusionBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'exclusion',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                vec3 exclusion(vec3 base, vec3 blend)\n                {\n                    return base + blend - 2.0 * base * blend;\n                }\n\n                vec3 blendExclusion(vec3 base, vec3 blend, float opacity)\n                {\n                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendExclusion(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                fn exclusion(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>\n                {\n                    return base+blend-2.0*base*blend;\n                }\n\n                fn blendExclusion(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                out = vec4<f32>(blendExclusion(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n            }\n        });\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * The final color is the result of multiply if the top color is darker, or screen if the top color is lighter.\n * This blend mode is equivalent to overlay but with the layers swapped.\n * The effect is similar to shining a harsh spotlight on the backdrop.\n *\n * Available as `container.blendMode = 'hard-light'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'hard-light'\n * @category filters\n * @noInheritDoc\n */\nexport class HardLightBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'hard-light',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float hardLight(float base, float blend)\n                {\n                    return (blend < 0.5) ? 2.0 * base * blend : 1.0 - 2.0 * (1.0 - base) * (1.0 - blend);\n                }\n\n                vec3 blendHardLight(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        hardLight(base.r, blend.r),\n                        hardLight(base.g, blend.g),\n                        hardLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                finalColor = vec4(blendHardLight(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n            `\n            },\n            gpu: {\n                functions: `\n                fn hardLight(base: f32, blend: f32) -> f32\n                {\n                    return select(1.0 - 2.0 * (1.0 - base) * (1.0 - blend), 2.0 * base * blend, blend < 0.5);\n                }\n\n                fn blendHardLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        hardLight(base.r, blend.r),\n                        hardLight(base.g, blend.g),\n                        hardLight(base.b, blend.b)\n                    );\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                out = vec4<f32>(blendHardLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n            }\n        });\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Hard defines each of the color channel values of the blend color to the RGB values of the base color.\n * If the sum of a channel is 255, it receives a value of 255; if less than 255, a value of 0.\n *\n * Available as `container.blendMode = 'hard-mix'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'hard-mix'\n * @category filters\n * @noInheritDoc\n */\nexport class HardMixBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'hard-mix',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float hardMix(float base, float blend)\n                {\n                    return (base + blend >= 1.0) ? 1.0 : 0.0;\n                }\n\n                vec3 blendHardMix(vec3 base, vec3 blend,  float opacity)\n                {\n                    vec3 blended = vec3(\n                        hardMix(base.r, blend.r),\n                        hardMix(base.g, blend.g),\n                        hardMix(base.b, blend.b)\n                    );\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                finalColor = vec4(blendHardMix(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n            `\n            },\n            gpu: {\n                functions: `\n                fn hardMix(base: f32, blend: f32) -> f32\n                {\n                    return select(0.0, 1.0, base + blend >= 1.0);\n                }\n\n                fn blendHardMix(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blended: vec3<f32> = vec3<f32>(\n                        hardMix(base.r, blend.r),\n                        hardMix(base.g, blend.g),\n                        hardMix(base.b, blend.b)\n                    );\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                out = vec4<f32>(blendHardMix(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n            }\n        });\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * The final color is composed of the lightest values of each color channel.\n *\n * Available as `container.blendMode = 'lighten'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'lighten'\n * @category filters\n * @noInheritDoc\n */\nexport class LightenBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'lighten',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                vec3 blendLighten(vec3 base, vec3 blend, float opacity)\n                {\n                    return (max(base, blend) * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendLighten(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                fn blendLighten(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    return (max(base, blend) * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                out = vec4<f32>(blendLighten(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n            }\n        });\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Looks at the color information in each channel and darkens the base color to\n * reflect the blend color by increasing the contrast between the two.\n *\n * Available as `container.blendMode = 'linear-burn'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'linear-burn'\n * @category filters\n * @noInheritDoc\n */\nexport class LinearBurnBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'linear-burn',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float linearBurn(float base, float blend)\n                {\n                    return max(0.0, base + blend - 1.0);\n                }\n\n                vec3 blendLinearBurn(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        linearBurn(base.r, blend.r),\n                        linearBurn(base.g, blend.g),\n                        linearBurn(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendLinearBurn(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                fn linearBurn(base: f32, blend: f32) -> f32\n                {\n                    return max(0.0, base + blend - 1.0);\n                }\n\n                fn blendLinearBurn(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        linearBurn(base.r, blend.r),\n                        linearBurn(base.g, blend.g),\n                        linearBurn(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                out = vec4<f32>(blendLinearBurn(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n            }\n        });\n    }\n}\n","/* eslint-disable max-len */\n\nimport { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Looks at the color information in each channel and brightens the base color to reflect the blend color by decreasing contrast between the two.\n *\n * Available as `container.blendMode = 'linear-dodge'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'linear-dodge'\n * @category filters\n * @noInheritDoc\n */\nexport class LinearDodgeBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'linear-dodge',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float linearDodge(float base, float blend) {\n                    return min(1.0, base + blend);\n                }\n\n                vec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {\n                    vec3 blended = vec3(\n                        linearDodge(base.r, blend.r),\n                        linearDodge(base.g, blend.g),\n                        linearDodge(base.b, blend.b)\n                    );\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendLinearDodge(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                fn linearDodge(base: f32, blend: f32) -> f32\n                {\n                    return min(1, base + blend);\n                }\n\n                fn blendLinearDodge(base:vec3<f32>, blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        linearDodge(base.r, blend.r),\n                        linearDodge(base.g, blend.g),\n                        linearDodge(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                out = vec4<f32>(blendLinearDodge(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n            }\n        });\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Increase or decrease brightness by burning or dodging color values, based on the blend color\n *\n * Available as `container.blendMode = 'linear-light'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'linear-light'\n * @category filters\n * @noInheritDoc\n */\nexport class LinearLightBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'linear-light',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float linearBurn(float base, float blend) {\n                    return max(0.0, base + blend - 1.0);\n                }\n\n                float linearDodge(float base, float blend) {\n                    return min(1.0, base + blend);\n                }\n\n                float linearLight(float base, float blend) {\n                    return (blend <= 0.5) ? linearBurn(base,2.0*blend) : linearBurn(base,2.0*(blend-0.5));\n                }\n\n                vec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {\n                    vec3 blended = vec3(\n                        linearLight(base.r, blend.r),\n                        linearLight(base.g, blend.g),\n                        linearLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                finalColor = vec4(blendLinearLight(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                fn linearBurn(base: f32, blend: f32) -> f32\n                {\n                    return max(0.0, base + blend - 1.0);\n                }\n\n                fn linearDodge(base: f32, blend: f32) -> f32\n                {\n                    return min(1.0, base + blend);\n                }\n\n                fn linearLight(base: f32, blend: f32) -> f32\n                {\n                    return select(linearBurn(base,2.0*(blend-0.5)), linearBurn(base,2.0*blend), blend <= 0.5);\n                }\n\n                fn blendLinearLightOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        linearLight(base.r, blend.r),\n                        linearLight(base.g, blend.g),\n                        linearLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                out = vec4<f32>(blendLinearLightOpacity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n            }\n        });\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\nimport { hslgl } from '../filters/blend-modes/hls/GLhls';\nimport { hslgpu } from '../filters/blend-modes/hls/GPUhls';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * The final color has the luminosity of the top color, while using the hue and saturation of the bottom color.\n * This blend mode is equivalent to color, but with the layers swapped.\n *\n * Available as `container.blendMode = 'luminosity'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'luminosity'\n * @category filters\n * @noInheritDoc\n */\nexport class LuminosityBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'luminosity',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                ${hslgl}\n\n                vec3 blendLuminosity(vec3 base, vec3 blend,  float opacity)\n                {\n                    vec3 blendLuminosity = setLuminosity(base, getLuminosity(blend));\n                    return (blendLuminosity * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendLuminosity(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                ${hslgpu}\n\n                fn blendLuminosity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blendLuminosity: vec3<f32> = setLuminosity(base, getLuminosity(blend));\n                    return (blendLuminosity * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                out = vec4<f32>(blendLuminosity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n            }\n        });\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Implements the Negation blend mode which creates an inverted effect based on the brightness values.\n *\n * Available as `container.blendMode = 'negation'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'negation'\n * @category filters\n * @noInheritDoc\n */\nexport class NegationBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'negation',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                vec3 negation(vec3 base, vec3 blend)\n                {\n                    return 1.0-abs(1.0-base-blend);\n                }\n\n                vec3 blendNegation(vec3 base, vec3 blend, float opacity)\n                {\n                    return (negation(base, blend) * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendNegation(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                fn blendNegation(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>\n                {\n                    return 1.0-abs(1.0-base-blend);\n                }\n\n                fn blendNegationOpacity(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    return (blendNegation(base, blend) * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                out = vec4<f32>(blendNegationOpacity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n            }\n        });\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * The final color is the result of multiply if the bottom color is darker, or screen if the bottom color is lighter.\n * This blend mode is equivalent to hard-light but with the layers swapped.\n *\n * Available as `container.blendMode = 'overlay'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'overlay'\n * @category filters\n * @noInheritDoc\n */\nexport class OverlayBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'overlay',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float overlay(float base, float blend)\n                {\n                    return (base < 0.5) ? (2.0*base*blend) : (1.0-2.0*(1.0-base)*(1.0-blend));\n                }\n\n                vec3 blendOverlay(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        overlay(base.r, blend.r),\n                        overlay(base.g, blend.g),\n                        overlay(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendOverlay(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `,\n            },\n            gpu: {\n                functions: `\n                fn overlay(base: f32, blend: f32) -> f32\n                {\n                    return select((1.0-2.0*(1.0-base)*(1.0-blend)), (2.0*base*blend), base < 0.5);\n                }\n\n                fn blendOverlay(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        overlay(base.r, blend.r),\n                        overlay(base.g, blend.g),\n                        overlay(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                out = vec4<f32>(blendOverlay(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `,\n            }\n        });\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Replaces colors based on the blend color.\n *\n * Available as `container.blendMode = 'pin-light'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'pin-light'\n * @category filters\n * @noInheritDoc\n */\nexport class PinLightBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'pin-light',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float pinLight(float base, float blend)\n                {\n                    return (blend <= 0.5) ? min(base, 2.0 * blend) : max(base, 2.0 * (blend - 0.5));\n                }\n\n                vec3 blendPinLight(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        pinLight(base.r, blend.r),\n                        pinLight(base.g, blend.g),\n                        pinLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                finalColor = vec4(blendPinLight(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                fn pinLight(base: f32, blend: f32) -> f32\n                {\n                    return select(max(base,2.0*(blend-0.5)), min(base,2.0*blend), blend <= 0.5);\n                }\n\n                fn blendPinLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        pinLight(base.r, blend.r),\n                        pinLight(base.g, blend.g),\n                        pinLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                out = vec4<f32>(blendPinLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n            }\n        });\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\nimport { hslgl } from '../filters/blend-modes/hls/GLhls';\nimport { hslgpu } from '../filters/blend-modes/hls/GPUhls';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * The final color has the saturation of the top color, while using the hue and luminosity of the bottom color.\n * A pure gray backdrop, having no saturation, will have no effect.\n *\n * Available as `container.blendMode = 'saturation'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'saturation'\n * @category filters\n * @noInheritDoc\n */\nexport class SaturationBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'saturation',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                ${hslgl}\n\n                vec3 blendSaturation(vec3 base, vec3 blend,  float opacity)\n                {\n                    vec3 blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));\n                    return (blendSaturation * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                finalColor = vec4(blendSaturation(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;\n            `\n            },\n            gpu: {\n                functions: `\n                ${hslgpu}\n\n                fn blendSaturation(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));\n                    return (blendSaturation * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                out = vec4<f32>(blendSaturation(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n            }\n        });\n    }\n}\n","/* eslint-disable max-len */\n\nimport { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * The final color is similar to hard-light, but softer. This blend mode behaves similar to hard-light.\n * The effect is similar to shining a diffused spotlight on the backdrop.\n *\n * Available as `container.blendMode = 'soft-light'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'soft-light'\n * @category filters\n * @noInheritDoc\n */\nexport class SoftLightBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'soft-light',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float softLight(float base, float blend)\n                {\n                    return (blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend));\n                }\n\n                vec3 blendSoftLight(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        softLight(base.r, blend.r),\n                        softLight(base.g, blend.g),\n                        softLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendSoftLight(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                fn softLight(base: f32, blend: f32) -> f32\n                {\n                    return select(2.0 * base * blend + base * base * (1.0 - 2.0 * blend), sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend), blend < 0.5);\n                }\n\n                fn blendSoftLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blended: vec3<f32> = vec3<f32>(\n                        softLight(base.r, blend.r),\n                        softLight(base.g, blend.g),\n                        softLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                out = vec4<f32>(blendSoftLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n            }\n        });\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Subtracts the blend from the base color using each color channel\n *\n * Available as `container.blendMode = 'subtract'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'subtract'\n * @category filters\n * @noInheritDoc\n */\nexport class SubtractBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'subtract',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float subtract(float base, float blend)\n                {\n                    return max(0.0, base - blend);\n                }\n\n                vec3 blendSubtract(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        subtract(base.r, blend.r),\n                        subtract(base.g, blend.g),\n                        subtract(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendSubtract(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                fn subtract(base: f32, blend: f32) -> f32\n                {\n                    return max(0, base - blend);\n                }\n\n                fn blendSubtract(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        subtract(base.r, blend.r),\n                        subtract(base.g, blend.g),\n                        subtract(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                out = vec4<f32>(blendSubtract(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n            }\n        });\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Darkens values darker than 50% gray and lightens those brighter than 50% gray, creating a dramatic effect.\n * It's essentially an extreme version of the Overlay mode, with a significant impact on midtones\n *\n * Available as `container.blendMode = 'vivid-light'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'vivid-light'\n * @category filters\n * @noInheritDoc\n */\nexport class VividLightBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'vivid-light',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float colorBurn(float base, float blend)\n                {\n                    return max((1.0-((1.0-base)/blend)),0.0);\n                }\n\n                float colorDodge(float base, float blend)\n                {\n                    return min(1.0, base / (1.0-blend));\n                }\n\n                float vividLight(float base, float blend)\n                {\n                    return (blend < 0.5) ? colorBurn(base,(2.0*blend)) : colorDodge(base,(2.0*(blend-0.5)));\n                }\n\n                vec3 blendVividLight(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        vividLight(base.r, blend.r),\n                        vividLight(base.g, blend.g),\n                        vividLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                finalColor = vec4(blendVividLight(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n            `\n            },\n            gpu: {\n                functions: `\n                fn colorBurn(base:f32, blend:f32) -> f32\n                {\n                    return max((1.0-((1.0-base)/blend)),0.0);\n                }\n\n                fn colorDodge(base: f32, blend: f32) -> f32\n                {\n                    return min(1.0, base / (1.0-blend));\n                }\n\n                fn vividLight(base: f32, blend: f32) -> f32\n                {\n                    return select(colorDodge(base,(2.0*(blend-0.5))), colorBurn(base,(2.0*blend)), blend<0.5);\n                }\n\n                fn blendVividLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    let blended: vec3<f32> = vec3<f32>(\n                        vividLight(base.r, blend.r),\n                        vividLight(base.g, blend.g),\n                        vividLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                out = vec4<f32>(blendVividLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n            }\n        });\n    }\n}\n","import { extensions } from '../extensions/Extensions';\nimport { ColorBlend } from './ColorBlend';\nimport { ColorBurnBlend } from './ColorBurnBlend';\nimport { ColorDodgeBlend } from './ColorDodgeBlend';\nimport { DarkenBlend } from './DarkenBlend';\nimport { DifferenceBlend } from './DifferenceBlend';\nimport { DivideBlend } from './DivideBlend';\nimport { ExclusionBlend } from './ExclusionBlend';\nimport { HardLightBlend } from './HardLightBlend';\nimport { HardMixBlend } from './HardMixBlend';\nimport { LightenBlend } from './LightenBlend';\nimport { LinearBurnBlend } from './LinearBurnBlend';\nimport { LinearDodgeBlend } from './LinearDodgeBlend';\nimport { LinearLightBlend } from './LinearLightBlend';\nimport { LuminosityBlend } from './LuminosityBlend';\nimport { NegationBlend } from './NegationBlend';\nimport { OverlayBlend } from './OverlayBlend';\nimport { PinLightBlend } from './PinLightBlend';\nimport { SaturationBlend } from './SaturationBlend';\nimport { SoftLightBlend } from './SoftLightBlend';\nimport { SubtractBlend } from './SubtractBlend';\nimport { VividLightBlend } from './VividLightBlend';\n\nextensions.add(\n    ColorBlend,\n    ColorBurnBlend,\n    ColorDodgeBlend,\n    DarkenBlend,\n    DifferenceBlend,\n    DivideBlend,\n    ExclusionBlend,\n    HardLightBlend,\n    HardMixBlend,\n    LightenBlend,\n    LinearBurnBlend,\n    LinearLightBlend,\n    LinearDodgeBlend,\n    LuminosityBlend,\n    NegationBlend,\n    OverlayBlend,\n    PinLightBlend,\n    SaturationBlend,\n    SoftLightBlend,\n    SubtractBlend,\n    VividLightBlend,\n);\n"],"names":["BlendModeFilter","hslgl","hslgpu","ColorBlend","ExtensionType","ColorBurnBlend","ColorDodgeBlend","DarkenBlend","DifferenceBlend","DivideBlend","ExclusionBlend","HardLightBlend","HardMixBlend","LightenBlend","LinearBurnBlend","LinearDodgeBlend","LinearLightBlend","LuminosityBlend","NegationBlend","OverlayBlend","PinLightBlend","SaturationBlend","SoftLightBlend","SubtractBlend","VividLightBlend","extensions","o","m","i","e","n","t","d","l","f","B","p","L","a","g","h","u","D","s","c","v","x"],"mappings":"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"}