<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Braille Chew - Sticky Physical</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@900&display=swap');
        
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            overflow: hidden; background: #1a030a; font-family: 'Nunito', sans-serif;
            touch-action: none;
        }

        .mouth-chamber {
            width: 100vw; height: 100vh;
            background: radial-gradient(circle at center, #800f2f 0%, #4d0a1b 100%);
            display: flex; flex-direction: column; justify-content: space-between;
            align-items: center; position: relative; overflow: hidden;
        }

        /* Throat & Uvula Layer */
        .background-throat {
            position: absolute; inset: 0; z-index: 1;
            display: flex; justify-content: center; align-items: center;
            pointer-events: none;
        }
        .throat-hole {
            width: 400px; height: 400px; background: #000; border-radius: 50%;
            box-shadow: 0 0 100px #800f2f, inset 0 0 50px #c9184a;
            position: relative;
        }
        .uvula {
            position: absolute; top: -20px; left: 50%; transform: translateX(-50%);
            width: 60px; height: 120px; background: #ff85a1;
            border-radius: 0 0 30px 30px; border: 4px solid #ff4d6d;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
            display: flex; flex-direction: column; align-items: center; justify-content: flex-end;
            padding-bottom: 15px; transition: top 0.5s ease-in-out;
        }
        .uvula-preview { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; }
        .u-dot { width: 8px; height: 8px; background: rgba(0,0,0,0.3); border-radius: 50%; transition: 0.1s; }
        .u-dot.active { background: #fff; box-shadow: 0 0 10px #fff; }

        /* Teeth Physics */
        .teeth-row { display: flex; gap: 10px; z-index: 50; transition: transform 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .tooth {
            width: 70px; height: 100px; background: #fdfdfd;
            border-bottom: 8px solid #ddd; border-radius: 0 0 15px 15px;
            display: flex; align-items: flex-end; justify-content: center;
            padding-bottom: 10px; font-weight: 900; color: #ced4da;
            box-shadow: inset 0 -10px 10px rgba(0,0,0,0.05);
        }
        .tooth.bottom { border-bottom: none; border-top: 8px solid #ddd; border-radius: 15px 15px 0 0; align-items: flex-start; padding-top: 10px; }
        .pressed { background: #ffb703 !important; transform: translateY(30px) !important; color: white; }
        .bottom.pressed { transform: translateY(-30px) !important; }

        /* Spongy Food Physics */
        .sponge-cube {
            width: 80px; height: 110px; border-radius: 15px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            position: relative; z-index: 30; border: 3px solid rgba(0,0,0,0.15);
            box-shadow: inset -5px -5px 0 rgba(0,0,0,0.1), 5px 10px 20px rgba(0,0,0,0.3);
            transition: transform 0.1s ease-out, scale 0.5s;
        }
        .sponge-letter { font-size: 3rem; font-weight: 900; color: rgba(0,0,0,0.6); line-height: 1; }
        .sponge-braille { display: grid; grid-template-columns: 1fr 1fr; gap: 3px; margin-top: 5px; }
        .s-dot { width: 8px; height: 8px; background: rgba(0,0,0,0.15); border-radius: 50%; }
        .s-dot.active { background: rgba(0,0,0,0.5); }

        #saliva-canvas { position: absolute; inset: 0; pointer-events: none; z-index: 40; }

        /* Tongue Upgrade */
        #tongue {
            position: absolute; width: 220px; height: 280px; background: #ff758f;
            border-radius: 110px 110px 40px 40px; border: 8px solid #ff4d6d;
            box-shadow: inset 0 20px 40px rgba(255,255,255,0.3), 0 20px 40px rgba(0,0,0,0.4);
            z-index: 45; pointer-events: none;
        }
        #tongue::after {
            content: ''; position: absolute; top: 20%; left: 50%; transform: translateX(-50%);
            width: 70%; height: 60%; border: 4px solid rgba(255,255,255,0.2); border-radius: 80px 80px 20px 20px;
        }

        /* Entrance / Win animations */
        .mouth-closed .teeth-top { transform: translateY(-120%); }
        .mouth-closed .teeth-bottom { transform: translateY(120%); }
        .zoom-in { animation: zoomIn 0.8s forwards; }
        @keyframes zoomIn { from { transform: scale(3); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        
        .hint-btn { cursor: pointer; transition: 0.2s; z-index: 100; }
        .hint-btn:hover { transform: scale(1.05); filter: brightness(1.2); }
    </style>
</head>
<body onclick="focusMouth()">

    <div id="start-screen" class="fixed inset-0 bg-black z-[200] flex flex-col items-center justify-center text-white" onclick="startLevel()">
        <h1 class="text-5xl font-black mb-4 text-rose-500 italic">STICKY BRAILLE</h1>
        <button class="bg-rose-600 px-12 py-6 rounded-full text-2xl font-black shadow-lg">BITE START</button>
    </div>

    <div class="mouth-chamber mouth-closed" id="chamber" tabindex="0">
        <!-- Background -->
        <div class="background-throat">
            <div class="throat-hole">
                <div class="uvula" id="uvula">
                    <div class="uvula-preview">
                        <div id="up-1" class="u-dot"></div><div id="up-4" class="u-dot"></div>
                        <div id="up-2" class="u-dot"></div><div id="up-5" class="u-dot"></div>
                        <div id="up-3" class="u-dot"></div><div id="up-6" class="u-dot"></div>
                    </div>
                </div>
            </div>
        </div>

        <canvas id="saliva-canvas"></canvas>

        <!-- Top Teeth -->
        <div class="teeth-row teeth-top" id="teethTop">
            <div id="t-s" class="tooth">S</div><div id="t-d" class="tooth">D</div><div id="t-f" class="tooth">F</div>
            <div style="width: 20px;"></div>
            <div id="t-j" class="tooth">J</div><div id="t-k" class="tooth">K</div><div id="t-l" class="tooth">L</div>
        </div>

        <!-- Food Stack -->
        <div id="foodStack" class="flex gap-1 items-center justify-center z-30"></div>

        <!-- Controls & Bottom Teeth -->
        <div class="flex flex-col items-center mb-0">
            <div class="hint-btn bg-black/60 text-yellow-400 px-8 py-3 rounded-full font-black mb-6 border-2 border-yellow-400/20" onclick="biteAuto()">
                HINT: <span id="hint">...</span>
            </div>
            <div class="teeth-row teeth-bottom" id="teethBottom">
                <div id="b-s" class="tooth bottom">S</div><div id="b-d" class="tooth bottom">D</div><div id="b-f" class="tooth bottom">F</div>
                <div style="width: 20px;"></div>
                <div id="b-j" class="tooth bottom">J</div><div id="b-k" class="tooth bottom">K</div><div id="b-l" class="tooth bottom">L</div>
            </div>
        </div>

        <div id="tongue"></div>
    </div>

<script>
    const BRAILLE = {
        'a': [1], 'b': [1, 2], 'c': [1, 4], 'd': [1, 4, 5], 'e': [1, 5], 'f': [1, 2, 4], 'g': [1, 2, 4, 5], 'h': [1, 2, 5], 'i': [2, 4], 'j': [2, 4, 5],
        'k': [1, 3], 'l': [1, 2, 3], 'm': [1, 3, 4], 'n': [1, 3, 4, 5], 'o': [1, 3, 5], 'p': [1, 2, 3, 4], 'q': [1, 2, 3, 4, 5], 'r': [1, 2, 3, 5],
        's': [2, 3, 4], 't': [2, 3, 4, 5], 'u': [1, 3, 6], 'v': [1, 2, 3, 6], 'w': [2, 4, 5, 6], 'x': [1, 3, 4, 6], 'y': [1, 3, 4, 5, 6], 'z': [1, 3, 5, 6]
    };
    const DOT_MAP = { 'f': 1, 'd': 2, 's': 3, 'j': 4, 'k': 5, 'l': 6 };
    const COLORS = ['#e9ff70', '#ffd670', '#ff9770', '#ff70a6', '#70d6ff', '#b9fbc0'];
    const CHAINS = [
        ["STARTLING", "STARTING", "STARING", "STRING", "STING", "SING", "SIN", "IN", "I", ""],
        ["PLANTS", "PLANT", "PANTS", "PANT", "PAN", "AN", "A", ""]
    ];

    let currentChain = 0, currentWord = 0, keysActive = new Set(), chordBuffer = new Set();
    let strands = []; // Physics strings
    const canvas = document.getElementById('saliva-canvas');
    const ctx = canvas.getContext('2d');
    const tongue = document.getElementById('tongue');
    let tonguePos = { x: 0, y: 0, lastX: 0, lastY: 0 };
    let lastLicked = null;

    function focusMouth() { document.getElementById('chamber').focus(); }

    function startLevel() {
        document.getElementById('start-screen').style.display = 'none';
        const chamber = document.getElementById('chamber');
        chamber.classList.add('mouth-closed');
        
        setTimeout(() => {
            currentWord = 0;
            render();
            chamber.classList.remove('mouth-closed');
            document.getElementById('foodStack').classList.add('zoom-in');
            setTimeout(() => document.getElementById('foodStack').classList.remove('zoom-in'), 800);
        }, 600);
        
        resize();
        requestAnimationFrame(physicsLoop);
    }

    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize);

    // Keyboard
    window.addEventListener('keydown', (e) => {
        const k = e.key.toLowerCase();
        if (DOT_MAP[k]) {
            e.preventDefault();
            keysActive.add(k);
            chordBuffer.add(DOT_MAP[k]);
            updateVisuals();
        }
    });

    window.addEventListener('keyup', (e) => {
        const k = e.key.toLowerCase();
        if (DOT_MAP[k]) {
            keysActive.delete(k);
            if (keysActive.size === 0) {
                bite(Array.from(chordBuffer).sort((a,b)=>a-b));
                chordBuffer.clear();
            }
            updateVisuals();
        }
    });

    function bite(chord) {
        const word = CHAINS[currentChain][currentWord];
        const letter = Object.keys(BRAILLE).find(l => JSON.stringify(BRAILLE[l].sort((a,b)=>a-b)) === JSON.stringify(chord))?.toUpperCase();
        if (!letter || !word.includes(letter)) return;

        const nextTarget = CHAINS[currentChain][currentWord+1];
        let foundIdx = -1;
        for(let i=0; i<word.length; i++) {
            if(word[i] === letter && word.slice(0, i) + word.slice(i+1) === nextTarget) { foundIdx = i; break; }
        }

        if (foundIdx !== -1) {
            triggerSwallow(foundIdx);
            currentWord++;
            setTimeout(() => {
                if (CHAINS[currentChain][currentWord] === "") {
                    currentChain = (currentChain + 1) % CHAINS.length;
                    startLevel();
                } else {
                    render();
                }
            }, 500);
        }
    }

    function biteAuto() {
        const word = CHAINS[currentChain][currentWord];
        const next = CHAINS[currentChain][currentWord+1];
        if (next === undefined) return;
        let temp = word;
        for(let c of next) temp = temp.replace(c, '');
        const letter = temp;
        const dots = BRAILLE[letter.toLowerCase()];
        bite(dots.sort((a,b)=>a-b));
    }

    function triggerSwallow(idx) {
        const sponges = document.querySelectorAll('.sponge-cube');
        const target = sponges[idx];
        const rect = target.getBoundingClientRect();
        const clone = target.cloneNode(true);
        clone.style.position = 'absolute';
        clone.style.left = rect.left + 'px';
        clone.style.top = rect.top + 'px';
        clone.style.zIndex = '1000';
        clone.style.transition = 'all 0.5s ease-in';
        document.body.appendChild(clone);
        target.style.visibility = 'hidden';
        
        requestAnimationFrame(() => {
            clone.style.transform = 'scale(0) rotate(360deg)';
            clone.style.left = '50%';
            clone.style.top = '50%';
            clone.style.opacity = '0';
        });
        setTimeout(() => clone.remove(), 500);
    }

    function updateVisuals() {
        for(let i=1; i<=6; i++) document.getElementById(`up-${i}`).classList.toggle('active', chordBuffer.has(i));
        ['s','d','f','j','k','l'].forEach(k => {
            const isDown = keysActive.has(k);
            document.getElementById(`t-${k}`).classList.toggle('pressed', isDown);
            document.getElementById(`b-${k}`).classList.toggle('pressed', isDown);
        });
    }

    function render() {
        const word = CHAINS[currentChain][currentWord];
        const container = document.getElementById('foodStack');
        container.innerHTML = '';
        
        // Scale logic
        const scale = word.length > 8 ? 0.6 : word.length > 6 ? 0.8 : 1;
        container.style.transform = `scale(${scale})`;

        let biteChar = null;
        const next = CHAINS[currentChain][currentWord+1];
        if(next) {
            let temp = word;
            for(let c of next) temp = temp.replace(c, '');
            biteChar = temp;
        }

        word.split('').forEach((char, i) => {
            const dots = BRAILLE[char.toLowerCase()];
            const s = document.createElement('div');
            s.className = 'sponge-cube target-sticky';
            s.style.backgroundColor = COLORS[i % COLORS.length];
            s.innerHTML = `<div class="sponge-letter ${char === biteChar ? 'underline decoration-yellow-400' : ''}">${char}</div>
                           <div class="sponge-braille">${[1,4,2,5,3,6].map(d => `<div class="s-dot ${dots.includes(d) ? 'active' : ''}"></div>`).join('')}</div>`;
            container.appendChild(s);
        });
        document.getElementById('hint').innerText = next === "" ? "THE END" : next;
    }

    function physicsLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Tongue Movement Repulsion
        const targets = document.querySelectorAll('.sponge-cube, .tooth');
        targets.forEach(t => {
            const r = t.getBoundingClientRect();
            const centerX = r.left + r.width/2;
            const centerY = r.top + r.height/2;
            const dx = tonguePos.x - centerX;
            const dy = tonguePos.y - centerY;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if(dist < 150) {
                const force = (150 - dist) / 10;
                const tx = -dx/dist * force;
                const ty = -dy/dist * force;
                t.style.transform = `translate(${tx}px, ${ty}px)`;
                
                // Saliva sticking logic
                if(dist < 60 && Math.random() > 0.9) {
                    if(lastLicked && lastLicked !== t) {
                        strands.push({ a: lastLicked, b: t, life: 1.0, offsetA: Math.random()*20, offsetB: Math.random()*20 });
                        lastLicked = null;
                    } else {
                        lastLicked = t;
                    }
                }
            }
        });

        // Draw Strands
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 2;
        strands = strands.filter(s => {
            if(s.life <= 0) return false;
            const rA = s.a.getBoundingClientRect();
            const rB = s.b.getBoundingClientRect();
            if(rA.width === 0 || rB.width === 0) return false;

            const x1 = rA.left + rA.width/2;
            const y1 = rA.top + rA.height/2;
            const x2 = rB.left + rB.width/2;
            const y2 = rB.top + rB.height/2;

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            // Catenary curve
            const cpX = (x1 + x2) / 2;
            const cpY = (y1 + y2) / 2 + 30; // sag
            ctx.quadraticCurveTo(cpX, cpY, x2, y2);
            ctx.stroke();

            if(Math.random() > 0.99) s.life -= 0.2; // random popping
            return true;
        });

        requestAnimationFrame(physicsLoop);
    }

    window.addEventListener('mousemove', (e) => {
        tonguePos.x = e.clientX; tonguePos.y = e.clientY;
        tongue.style.left = (e.clientX - 110) + 'px';
        tongue.style.top = (e.clientY - 80) + 'px';
    });
    window.addEventListener('touchmove', (e) => {
        const t = e.touches[0];
        tonguePos.x = t.clientX; tonguePos.y = t.clientY;
        tongue.style.left = (t.clientX - 110) + 'px';
        tongue.style.top = (t.clientY - 80) + 'px';
    });
</script>
</body>
</html>